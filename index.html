<!DOCTYPE html>
<html>
<head>
  <title>Time Tunnel</title>
  <style>
    body { 
      margin: 0; 
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #ddd;
    }

    canvas { 
      width: 100%; 
      height: 100%;
    }

    .label {
      position: absolute;
      width: 100%;
      text-align: center;
      top: 0;
      color: #fff;
    }
    #blocker {

      position: absolute;

      width: 100%;
      height: 100%;

      background-color: rgba(0,0,0,0.5);

    }

    #instructions {

      width: 100%;
      height: 100%;

      display: -webkit-box;
      display: -moz-box;
      display: box;

      -webkit-box-orient: horizontal;
      -moz-box-orient: horizontal;
      box-orient: horizontal;

      -webkit-box-pack: center;
      -moz-box-pack: center;
      box-pack: center;

      -webkit-box-align: center;
      -moz-box-align: center;
      box-align: center;

      color: #ffffff;
      text-align: center;

      cursor: pointer;

    }
  </style>
</head>
<body>
  <script src="three.min.js"></script>
  <script src="OrbitControls.js"></script>
  <script type="text/javascript" src="helvetiker_regular.typeface.json"></script>
  <script src="PointerLockControls.js"></script>

  <div id="blocker">

    <div id="instructions">
      <span style="font-size:40px">Click to play</span>
      <br />
      (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
    </div>

  </div>

  <script>
var scene, camera, renderer;
var objects = [];
var controls;
var raycaster;
var blocker = document.getElementById( 'blocker' );
var instructions = document.getElementById( 'instructions' );

var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

if ( havePointerLock ) {

    var element = document.body;

    var pointerlockchange = function ( event ) {

        if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

            controlsEnabled = true;
            controls.enabled = true;

            blocker.style.display = 'none';

        } else {

            controls.enabled = false;

            blocker.style.display = 'block';

            instructions.style.display = '';

        }

    };

    var pointerlockerror = function ( event ) {

        instructions.style.display = '';

    };

    // Hook pointer lock state change events
    document.addEventListener( 'pointerlockchange', pointerlockchange, false );
    document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
    document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

    document.addEventListener( 'pointerlockerror', pointerlockerror, false );
    document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
    document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

    instructions.addEventListener( 'click', function ( event ) {

        instructions.style.display = 'none';

        // Ask the browser to lock the pointer
        element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
        element.requestPointerLock();

    }, false );

} else {

    instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
}

var controlsEnabled = false;

var moveForward = false;
var moveBackward = false;
var moveLeft = false;
var moveRight = false;
var canJump = false;

var prevTime = performance.now();
var velocity = new THREE.Vector3();
var direction = new THREE.Vector3();


var PhotoFrame = function(woodMaterial, pictureMaterial, timeStamp, scaleFactor, frameType) {

    THREE.Group.apply(this, arguments);

    scaleFactor = arguments[3] ? arguments[3] : 1;
    frameType = arguments[4] ? arguments[4] : 0;
    var geometry
    if(frameType == 0){
      geometry = new THREE.BoxGeometry(27, 9, 80);
    }
    else{
      geometry = new THREE.BoxGeometry(46, 9, 80);
    }
     
    var bottom = new THREE.Mesh(geometry, woodMaterial);
    bottom.castShadow = true;
    bottom.receiveShadow = true;
    bottom.scale.set(scaleFactor, scaleFactor, scaleFactor);
    this.add(bottom);

    var geometry2 = new THREE.BoxGeometry(60, 9, 80);
    var frame = new THREE.Mesh(geometry2, woodMaterial);
    frame.castShadow = true;
    frame.receiveShadow = true;
    if(frameType == 0){
      frame.rotateZ(Math.PI / 2);
      frame.position.y += 34.5 * scaleFactor;
    }
    else{
      frame.rotateZ(Math.PI * 2 / 3);
      frame.position.x += 11.897 * scaleFactor;
      frame.position.y += 23.731 * scaleFactor;
    }
    frame.scale.set(scaleFactor, scaleFactor, scaleFactor);
    this.add(frame);

    // var square = new THREE.Geometry();
    // var v1 = new THREE.Vector3(-27,0,36);
    // var v2 = new THREE.Vector3(27,0,36);
    // var v3 = new THREE.Vector3(27,0,-36);
    // var v4 = new THREE.Vector3(-27,0,-36);     
    // square.vertices.push( v1 );
    // square.vertices.push( v2 );
    // square.vertices.push( v3 ); 
    // square.vertices.push( v4 );
    // square.faces.push( new THREE.Face3( 0, 3, 1 ) ); 
    // square.faces.push( new THREE.Face3( 3, 2, 1 ) ); 

    // var textureCoord = [new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)];

    // square.faceVertexUvs[0] = [];
    // square.faceVertexUvs[0][0] = [ textureCoord[0], textureCoord[1], textureCoord[3] ];
    // square.faceVertexUvs[0][1] = [ textureCoord[1], textureCoord[2], textureCoord[3] ];

    var square2 = new THREE.BoxGeometry(72, 0.4, 54);
    var picture = new THREE.Mesh(square2, pictureMaterial);
    picture.castShadow = true;
    picture.receiveShadow = true;
    if(frameType == 0){
      picture.rotateZ(- Math.PI / 2);
      picture.rotateY(Math.PI / 2);
      picture.position.x += 4.5 * scaleFactor;
      picture.position.y += 34.5 * scaleFactor;
    }
    else{
      picture.rotateZ(- Math.PI / 3);
      picture.rotateY(Math.PI / 2);
      picture.position.x += 15.794 * scaleFactor;
      picture.position.y += 25.981 * scaleFactor;
    }
    picture.scale.set(scaleFactor, scaleFactor, scaleFactor);
    this.add(picture);

    var fontMaterial = new THREE.MeshPhongMaterial({    
      color: 0xffff00,
      specular:0xffff00,    
      shininess:0
    });
    // load font
    var fontLoader = new THREE.FontLoader();
    var mainThis = this;
    fontLoader.load('helvetiker_regular.typeface.json', function(font) {
      var fontMesh = new THREE.Mesh(new THREE.TextGeometry(timeStamp, {
        font: font,
        size: 10 * scaleFactor,
        height: 1
      }), fontMaterial);
      fontMesh.castShadow = true;
      fontMesh.receiveShadow = true;
      if(frameType == 0){
        fontMesh.rotateY(Math.PI / 2);
        fontMesh.position.x += 24.5 * scaleFactor;
        fontMesh.position.z -= 42 * scaleFactor;
      }
      else{
        fontMesh.rotateY(Math.PI / 2);
        fontMesh.position.x += 34 * scaleFactor;
        fontMesh.position.z -= 42 * scaleFactor;
      }
      
      mainThis.add(fontMesh);
    });

    var pointLight = new THREE.PointLight(0xffffee, 1, 200, 2);
    pointLight.castShadow = true;
    pointLight.position.set(40 * scaleFactor, 80 * scaleFactor, 0 * scaleFactor);
    this.add(pointLight);

    // light
    var lightGeometry = new THREE.SphereGeometry(5, 32, 32);
    var lightMaterial = new THREE.MeshBasicMaterial( {color: 0xffffee} );
    var lightMesh = new THREE.Mesh( lightGeometry, lightMaterial );
    lightMesh.position.set(40 * scaleFactor, 80 * scaleFactor, 0 * scaleFactor);
    this.add( lightMesh );
}
PhotoFrame.prototype = Object.create(THREE.Group.prototype);
PhotoFrame.prototype.constructor = PhotoFrame;
PhotoFrame.prototype.updatePosition = function() {
    // this.rotateY(-0.005);
};


init();
initLights();
initGround();
initRoad();


// A photo frame on top
var woodMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture('images/wood.jpg') } );
var pictureMaterial = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture('images/mayun.jpg') } );
var pictureMaterial2 = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture('images/mayun2.jpg') } );
var photoFrame = new PhotoFrame(woodMaterial, pictureMaterial, '2017.11.20');
photoFrame.rotateY(Math.PI * 3.5  / 4);
photoFrame.position.x += 90;
photoFrame.position.y += 4.5;
scene.add(photoFrame);
objects.push(photoFrame);

var photoFrame2 = new PhotoFrame(woodMaterial, pictureMaterial2, '2017.11.17');
photoFrame2.rotateY( Math.PI * 0.88 / 4);
photoFrame2.rotateY(- Math.PI / 2);
photoFrame2.position.y += 4.5;
photoFrame2.position.x -= 200;
scene.add(photoFrame2);
objects.push(photoFrame2);




// Add an orbit control which allows us to move around the scene. See the three.js example for more details
// https://github.com/mrdoob/three.js/blob/dev/examples/js/controls/OrbitControls.
//var controls_test = new THREE.OrbitControls( camera, renderer.domElement );
//controls_test.target = new THREE.Vector3(0,80,0);
//controls_test.maxPolarAngle = Math.PI / 2;
//controls_test.minDistance = 100;
//controls_test.maxDistance = 220;

controls = new THREE.PointerLockControls( camera );
scene.add( controls.getObject() );

requestAnimationFrame(render);

function firstpersonControl()
{
    if ( controlsEnabled === true ) {

        raycaster.ray.origin.copy( controls.getObject().position );
        raycaster.ray.origin.y -= 10;

        var intersections = raycaster.intersectObjects( objects );

        var onObject = intersections.length > 0;

        var time = performance.now();
        var delta = ( time - prevTime ) / 1000;

        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

        direction.z = Number( moveForward ) - Number( moveBackward );
        direction.x = Number( moveLeft ) - Number( moveRight );
        direction.normalize(); // this ensures consistent movements in all directions

        if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
        if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

        if ( onObject === true ) {

            velocity.y = Math.max( 0, velocity.y );
            canJump = true;

        }

        controls.getObject().translateX( velocity.x * delta );
        controls.getObject().translateY( velocity.y * delta );
        controls.getObject().translateZ( velocity.z * delta );

        if ( controls.getObject().position.y < 10 ) {

            velocity.y = 0;
            controls.getObject().position.y = 10;

            canJump = true;

        }

        prevTime = time;

    }
}

function render() {
    //controls_test.update();

    // Update animated elements
    // tree.updatePosition();
    photoFrame.updatePosition();

    //fistpersoncontrol detection
    firstpersonControl();

    // Render the scene/camera combnation
    renderer.render(scene, camera);
    requestAnimationFrame(render);
}

var onKeyDown = function ( event ) {

    switch ( event.keyCode ) {

        case 38: // up
        case 87: // w
            moveForward = true;
            break;

        case 37: // left
        case 65: // a
            moveLeft = true; break;

        case 40: // down
        case 83: // s
            moveBackward = true;
            break;

        case 39: // right
        case 68: // d
            moveRight = true;
            break;

        case 32: // space
            if ( canJump === true ) velocity.y += 350;
            canJump = false;
            break;

    }

};

var onKeyUp = function ( event ) {

    switch( event.keyCode ) {

        case 38: // up
        case 87: // w
            moveForward = false;
            break;

        case 37: // left
        case 65: // a
            moveLeft = false;
            break;

        case 40: // down
        case 83: // s
            moveBackward = false;
            break;

        case 39: // right
        case 68: // d
            moveRight = false;
            break;

    }

};

document.addEventListener( 'keydown', onKeyDown, false );
document.addEventListener( 'keyup', onKeyUp, false );

raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );
/**
 * Helper function to add random noise to geometry vertixes
 *
 * @param geometry The geometry to alter
 * @param noiseX Amount of noise on the X axis
 * @param noiseY Amount of noise on the Y axis
 * @param noiseZ Amount of noise on the Z axis
 * @returns the geometry object
 */
function addNoise(geometry, noiseX, noiseY, noiseZ) {

    var noiseX = noiseX || 2;
    var noiseY = noiseY || noiseX;
    var noiseZ = noiseZ || noiseY;

    for(var i = 0; i < geometry.vertices.length; i++){
        var v = geometry.vertices[i];
        v.x += -noiseX / 2 + Math.random() * noiseX;
        v.y += -noiseY / 2 + Math.random() * noiseY;
        v.z += -noiseZ / 2 + Math.random() * noiseZ;
    }

    return geometry;
}

function addShapeNoise(shapes, noiseX, noiseY) {

    var noiseX = noiseX || 2;
    var noiseY = noiseY || noiseX;

    for(var i = 0; i < shapes.length; i++){
        var v = shapes[i];
        v.x += -noiseX / 2 + Math.random() * noiseX;
        v.y += -noiseY / 2 + Math.random() * noiseY;
        shapes[i] = v;
    }

    return shapes;
}


function loadTexture(texture, fileRoute) {
  var textureLoader = new THREE.TextureLoader();
  // textureLoader.crossOrigin = true;
  texture = textureLoader.load(fileRoute, function(texture) {
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;  
  });
}

function addSpotLight(){
  var pointColor = "#ffffee";
  var spotLight = new THREE.SpotLight(pointColor);
  spotLight.position.set(0, 100, 0);
  spotLight.castShadow = true;
  spotLight.shadowCameraNear = 1;
  spotLight.shadowCameraFar = 400;
  spotLight.shadowCameraFov = 30;


  var target = new THREE.Object3D();
  target.position = new THREE.Vector3(0, 0, 0);
  scene.add(target);
  spotLight.target = target;
  spotLight.distance = 400;
  spotLight.angle = 0.1;
  // spotLight.shadowCameraVisible = true;

  // light
  var lightGeometry = new THREE.SphereGeometry(5, 32, 32);
  var lightMaterial = new THREE.MeshBasicMaterial( {color: 0xffffee} );
  var lightMesh = new THREE.Mesh( lightGeometry, lightMaterial );
  lightMesh.position.set(0, 100, 0);
  scene.add( lightMesh );

  return spotLight;
}

function init(){
  // Create a scene which will hold all our meshes to be rendered
  scene = new THREE.Scene();
  //scene.fog = new THREE.Fog( 0xffffff, 0, 750 );

  // Create and position a camera
  camera = new THREE.PerspectiveCamera(
    75,                                   // Field of view
    window.innerWidth/window.innerHeight, // Aspect ratio
    0.1,                                  // Near clipping pane
    1000                                  // Far clipping pane
    );

  // Reposition the camera
  camera.position.set(10,30,20);

  // Point the camera at a given coordinate
  camera.lookAt(new THREE.Vector3(0,0,0));

  // Create a renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });

  // Size should be the same as the window
  renderer.setSize( window.innerWidth, window.innerHeight );

  // Set a near white clear color (default is black)
  // renderer.setClearColor( 0xfff6e6 );
  renderer.setClearColor( 0x000000 );

  // Enable shadow mapping
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  // Append to the document
  document.body.appendChild( renderer.domElement );
  var element = document.body;
    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
    element.requestPointerLock();
}

function initLights(){
  // Add an ambient lights
  var ambientLight = new THREE.AmbientLight( 0xffffff, 0.1 );
  scene.add( ambientLight );

  // Add a point light that will cast shadows
  // var pointLight = new THREE.PointLight( 0xffffff,.8 );
  // pointLight.position.set( 80, 160, 120 );
  // pointLight.castShadow = true;
  // pointLight.shadow.mapSize.width = 1024;
  // pointLight.shadow.mapSize.height = 1024;
  //scene.add( pointLight );

  var spotLight = addSpotLight();

  scene.add(spotLight);
}

function initGround(){
  var loader = new THREE.TextureLoader();
  var groundTexture = loader.load( 'images/floor.jpg', function ( texture ) {
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.offset.set( 0, 0 );
    texture.repeat.set( 20, 20 );
  } );
  var shadowMaterial = new THREE.MeshPhongMaterial( { map: groundTexture } );
  // shadowMaterial.opacity = 0.8;
  var groundMesh = new THREE.Mesh(
    new THREE.BoxGeometry( 1000, .1, 1000 ),
    shadowMaterial
    );
  groundMesh.receiveShadow = true;
  scene.add( groundMesh );
}

function initRoad(){
  var loader2 = new THREE.TextureLoader();
  var groundTexture2 = loader2.load( 'images/carpet.jpg', function ( texture ) {
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.offset.set( 0, 0 );
    texture.repeat.set( 1, 5 );
  } );
  var roadMaterial = new THREE.MeshPhongMaterial( { map: groundTexture2 } );
  // roadMaterial.opacity = 0.8;

  var roadMesh1 = new THREE.Mesh(
    new THREE.BoxGeometry( 100, .3, 471.405 ),
    roadMaterial
    );
  roadMesh1.rotateY(Math.PI / 4);
  roadMesh1.position.z += 333.333;
  roadMesh1.receiveShadow = true;
  scene.add( roadMesh1 );

  var roadMesh2 = new THREE.Mesh(
    new THREE.BoxGeometry( 100, .3, 471.405 ),
    roadMaterial
    );
  roadMesh2.rotateY(- Math.PI / 4);
  roadMesh2.position.x -= 70.711;
  roadMesh2.receiveShadow = true;
  scene.add( roadMesh2 );

  var roadMesh3 = new THREE.Mesh(
    new THREE.BoxGeometry( 100, .3, 471.405 ),
    roadMaterial
    );
  roadMesh3.rotateY(Math.PI / 4);
  roadMesh3.position.z -= 333.333;
  roadMesh3.receiveShadow = true;
  scene.add( roadMesh3 );
}



  </script>
</body>
</html>